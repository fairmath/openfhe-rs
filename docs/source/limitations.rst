Limitations
===========

OpenFHE
-------

See the `Security Notes for Homomorphic Encryption <https://openfhe-development.readthedocs.io/en/latest/sphinx_rsts/intro/security.html>`_ in OpenFHE's documentation.

Rust wrapper
------------

At the moment, only a certain set of OpenFHE functionality has been implemented.

We use the `CXX crate <https://cxx.rs/>`_ for our Rust binding to reduce the amount of abstraction levels. OpenFHE types are represented as opaque types on the Rust side using `cxx::UniquePtr <https://docs.rs/cxx/latest/cxx/struct.UniquePtr.html>`_ from the CXX crate. Instead of the usual `std::vec <https://doc.rust-lang.org/std/vec/>`_, we use `cxx::CxxVector <https://docs.rs/cxx/latest/cxx/struct.CxxVector.html>`_ for primitive types, and also `cxx::CxxVector<ComplexPair>` for representing `std::vector<std::complex<double>>` type.

The main difference lies in the current `cxx::CxxVector` supported functional, limited compared to `std::vector`, e.g. you need to init `cxx::CxxVector` element by element. Since `cxx` currently does not support `cxx::CxxVector` of opaque types, we are using a separate type for each vector of opaque type. Since `CXX` currently does not support alternatives for `std::unordered_map` and `std::map`, we are using separate types for them. The implementations of these types are very simple because we are planning to switch `cxx` variants further. But before switching these types can be extended to support basic functional of `std::vector`, `std::map` and `std::unordered_map` if required.

Since Rust does not support default parameters and function overloading, default parameters are mentioned in comments after the corresponding parameter name, and overloaded functions are represented by slightly different names. Calling member functions of instances, generated by GenNullâ€¦ functions results in undefined behavior.

Since `CXX` crate has limited support for function pointers (only functions without a return type are supported), EvalChebychevFunction expects fn(f64, ret: &mut f64) as the callable object.
